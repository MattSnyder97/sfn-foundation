// node src/lib/helper.js
import fs from "fs";
import path from "path";
import axios from "axios";
import readline from "readline";
import dotenv from "dotenv";
dotenv.config();

// --- generateContentIndex logic ---
function generateContentIndex() {
  const contentDirs = [
    "src/content/info-pages/about-the-foundation",
    "src/content/info-pages/about",
    "src/content/info-pages/research",
    "src/content/info-pages/resources",
    "src/content/legal",
    "src/content/patient-stories",
  ];

  const sectionMap = {
    "src/content/info-pages/about-the-foundation": "About the Foundation",
    "src/content/info-pages/about": "About",
    "src/content/info-pages/research": "Research",
    "src/content/info-pages/resources": "Resources",
    "src/content/legal": "Legal",
    "src/content/patient-stories": "Patient Stories",
  };

  const indexFile = "src/content/index.ts";
  const imports = [];
  const sectionVars = {};

  contentDirs.forEach((dir) => {
    const section = sectionMap[dir] || dir;
    const files = fs.readdirSync(dir).filter((f) => f.endsWith(".ts"));
    imports.push(`\n// ===== ${section} =====`);
    sectionVars[section] = [];
    files.forEach((file) => {
      const base = file.replace(/\.ts$/, "");
      const varName =
        base
          .replace(/-([a-z])/g, (_, c) => c.toUpperCase())
          .replace(/^[a-z]/, (c) => c.toLowerCase()) + "Content";
      const importPath =
        "./" +
        path.relative("src/content", path.join(dir, base)).replace(/\\/g, "/");
      imports.push(`import { ${varName} } from "${importPath}";`);
      sectionVars[section].push(varName);
    });
  });

  let allContentOutput = "export const allContent = [\n";
  Object.keys(sectionVars).forEach((section) => {
    allContentOutput += `  // ${section}\n`;
    sectionVars[section].forEach((v) => {
      allContentOutput += `  ...[${v}],\n`;
    });
    allContentOutput += "\n";
  });
  allContentOutput += "]\n";

  const output = `// AUTO-GENERATED BY /lib/generateContentIndex.js\n\n// Run "node src/lib/generateContentIndex.js" to generate\n\n${imports.join(
    "\n"
  )}\n\n${allContentOutput}`;

  fs.writeFileSync(indexFile, output);
  console.log(
    `Generated ${indexFile} with ${
      Object.values(sectionVars).flat().length
    } content modules.`
  );
}

// --- tinypngReduce logic ---
function tinyPNGReduce() {
  const TINYPNG_API_KEY = process.env.TINYPING_API_KEY;
  const imagesDir = path.join(process.cwd(), "public/images");
  const subfolders = fs
    .readdirSync(imagesDir)
    .filter((f) => fs.statSync(path.join(imagesDir, f)).isDirectory());

  if (subfolders.length === 0) {
    console.log("No subfolders found in /public/images/");
    return;
  }

  console.log("Subfolders in /public/images/:");
  subfolders.forEach((folder, idx) => {
    console.log(`${idx + 1}: ${folder}`);
  });

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

  rl.question("Enter the number of the subfolder to compress: ", async (choice) => {
    const selected = subfolders[parseInt(choice) - 1];
    if (!selected) {
      console.log("Invalid selection.");
      rl.close();
      return;
    }
    const targetDir = path.join(imagesDir, selected);
    const files = fs.readdirSync(targetDir).filter((f) => {
      const filePath = path.join(targetDir, f);
      const isImage = /\.(png|jpg|jpeg)$/i.test(f);
      if (!isImage) return false;
      const stats = fs.statSync(filePath);
      return stats.size >= 600 * 1024;
    });

    if (files.length === 0) {
      console.log("No images found to reduce. All files were under 600kb or not PNG/JPG/JPEG.");
      rl.close();
      return;
    }

    console.log(`Compressing ${files.length} images in ${selected}...`);
    let reducedCount = 0;
    let reducedFiles = [];

    async function compressImage(filePath) {
      const fileData = fs.readFileSync(filePath);
      const originalSize = fs.statSync(filePath).size;
      try {
        const uploadRes = await axios.post("https://api.tinify.com/shrink", fileData, {
          auth: { username: "api", password: TINYPNG_API_KEY },
          headers: { "Content-Type": "application/octet-stream" },
        });
        const compressedUrl = uploadRes.data.output.url;
        const compressedRes = await axios.get(compressedUrl, { responseType: "arraybuffer" });
        fs.writeFileSync(filePath, compressedRes.data);
        const newSize = fs.statSync(filePath).size;
        if (newSize < originalSize) {
          reducedCount++;
          reducedFiles.push(path.basename(filePath));
        }
        console.log(`Compressed: ${path.basename(filePath)}`);
      } catch (err) {
        console.error(
          `Error compressing ${path.basename(filePath)}:`,
          err.response ? err.response.data : err.message
        );
      }
    }

    for (const file of files) {
      await compressImage(path.join(targetDir, file));
    }

    if (reducedCount > 0) {
      console.log(`Compression complete. Images reduced: ${reducedCount}`);
      console.log("Reduced files:");
      reducedFiles.forEach((f) => console.log(`- ${f}`));
    } else {
      console.log("No images reduced because all files were under 600kb or did not reduce in size.");
    }

    rl.close();
  });
}

function showMenu() {
  console.log("Select a utility to run:");
  console.log("1. Generate Content Index");
  console.log("2. Reduce Images with TinyPNG");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  rl.question("Enter your choice (1 or 2): ", (answer) => {
    if (answer === "1") {
      generateContentIndex();
    } else if (answer === "2") {
      tinyPNGReduce();
    } else {
      console.log("Invalid choice.");
    }
    rl.close();
  });
}

showMenu();
